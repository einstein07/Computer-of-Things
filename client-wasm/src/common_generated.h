// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_WORKPACKAGE_COMMON_H_
#define FLATBUFFERS_GENERATED_COMMON_WORKPACKAGE_COMMON_H_

#include "flatbuffers/flatbuffers.h"

namespace workpackage {
namespace common {

struct Matrix2D;

struct Matrix3D;

struct MatrixND;

enum Matrix {
  Matrix_NONE = 0,
  Matrix_Matrix2D = 1,
  Matrix_Matrix3D = 2,
  Matrix_MatrixND = 3,
  Matrix_MIN = Matrix_NONE,
  Matrix_MAX = Matrix_MatrixND
};

inline const Matrix (&EnumValuesMatrix())[4] {
  static const Matrix values[] = {
    Matrix_NONE,
    Matrix_Matrix2D,
    Matrix_Matrix3D,
    Matrix_MatrixND
  };
  return values;
}

inline const char * const *EnumNamesMatrix() {
  static const char * const names[] = {
    "NONE",
    "Matrix2D",
    "Matrix3D",
    "MatrixND",
    nullptr
  };
  return names;
}

inline const char *EnumNameMatrix(Matrix e) {
  if (e < Matrix_NONE || e > Matrix_MatrixND) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMatrix()[index];
}

template<typename T> struct MatrixTraits {
  static const Matrix enum_value = Matrix_NONE;
};

template<> struct MatrixTraits<Matrix2D> {
  static const Matrix enum_value = Matrix_Matrix2D;
};

template<> struct MatrixTraits<Matrix3D> {
  static const Matrix enum_value = Matrix_Matrix3D;
};

template<> struct MatrixTraits<MatrixND> {
  static const Matrix enum_value = Matrix_MatrixND;
};

bool VerifyMatrix(flatbuffers::Verifier &verifier, const void *obj, Matrix type);
bool VerifyMatrixVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Matrix2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_N_ROWS = 4,
    VT_N_COLS = 6,
    VT_ELEMENTS = 8
  };
  int32_t n_rows() const {
    return GetField<int32_t>(VT_N_ROWS, 0);
  }
  int32_t n_cols() const {
    return GetField<int32_t>(VT_N_COLS, 0);
  }
  const flatbuffers::Vector<float> *elements() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ELEMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_N_ROWS) &&
           VerifyField<int32_t>(verifier, VT_N_COLS) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           verifier.EndTable();
  }
};

struct Matrix2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_n_rows(int32_t n_rows) {
    fbb_.AddElement<int32_t>(Matrix2D::VT_N_ROWS, n_rows, 0);
  }
  void add_n_cols(int32_t n_cols) {
    fbb_.AddElement<int32_t>(Matrix2D::VT_N_COLS, n_cols, 0);
  }
  void add_elements(flatbuffers::Offset<flatbuffers::Vector<float>> elements) {
    fbb_.AddOffset(Matrix2D::VT_ELEMENTS, elements);
  }
  explicit Matrix2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Matrix2DBuilder &operator=(const Matrix2DBuilder &);
  flatbuffers::Offset<Matrix2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Matrix2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Matrix2D> CreateMatrix2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t n_rows = 0,
    int32_t n_cols = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> elements = 0) {
  Matrix2DBuilder builder_(_fbb);
  builder_.add_elements(elements);
  builder_.add_n_cols(n_cols);
  builder_.add_n_rows(n_rows);
  return builder_.Finish();
}

inline flatbuffers::Offset<Matrix2D> CreateMatrix2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t n_rows = 0,
    int32_t n_cols = 0,
    const std::vector<float> *elements = nullptr) {
  auto elements__ = elements ? _fbb.CreateVector<float>(*elements) : 0;
  return workpackage::common::CreateMatrix2D(
      _fbb,
      n_rows,
      n_cols,
      elements__);
}

struct Matrix3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_ROWS = 4,
    VT_NUM_COLS = 6,
    VT_NUM_PAGES = 8,
    VT_ELEMENTS = 10
  };
  int32_t num_rows() const {
    return GetField<int32_t>(VT_NUM_ROWS, 0);
  }
  int32_t num_cols() const {
    return GetField<int32_t>(VT_NUM_COLS, 0);
  }
  int32_t num_pages() const {
    return GetField<int32_t>(VT_NUM_PAGES, 0);
  }
  const flatbuffers::Vector<float> *elements() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ELEMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_ROWS) &&
           VerifyField<int32_t>(verifier, VT_NUM_COLS) &&
           VerifyField<int32_t>(verifier, VT_NUM_PAGES) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           verifier.EndTable();
  }
};

struct Matrix3DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_rows(int32_t num_rows) {
    fbb_.AddElement<int32_t>(Matrix3D::VT_NUM_ROWS, num_rows, 0);
  }
  void add_num_cols(int32_t num_cols) {
    fbb_.AddElement<int32_t>(Matrix3D::VT_NUM_COLS, num_cols, 0);
  }
  void add_num_pages(int32_t num_pages) {
    fbb_.AddElement<int32_t>(Matrix3D::VT_NUM_PAGES, num_pages, 0);
  }
  void add_elements(flatbuffers::Offset<flatbuffers::Vector<float>> elements) {
    fbb_.AddOffset(Matrix3D::VT_ELEMENTS, elements);
  }
  explicit Matrix3DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Matrix3DBuilder &operator=(const Matrix3DBuilder &);
  flatbuffers::Offset<Matrix3D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Matrix3D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Matrix3D> CreateMatrix3D(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_rows = 0,
    int32_t num_cols = 0,
    int32_t num_pages = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> elements = 0) {
  Matrix3DBuilder builder_(_fbb);
  builder_.add_elements(elements);
  builder_.add_num_pages(num_pages);
  builder_.add_num_cols(num_cols);
  builder_.add_num_rows(num_rows);
  return builder_.Finish();
}

inline flatbuffers::Offset<Matrix3D> CreateMatrix3DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_rows = 0,
    int32_t num_cols = 0,
    int32_t num_pages = 0,
    const std::vector<float> *elements = nullptr) {
  auto elements__ = elements ? _fbb.CreateVector<float>(*elements) : 0;
  return workpackage::common::CreateMatrix3D(
      _fbb,
      num_rows,
      num_cols,
      num_pages,
      elements__);
}

struct MatrixND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_DIMS = 4,
    VT_DIM_SIZES = 6,
    VT_ELEMENTS = 8
  };
  int32_t num_dims() const {
    return GetField<int32_t>(VT_NUM_DIMS, 0);
  }
  const flatbuffers::Vector<int32_t> *dim_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIM_SIZES);
  }
  const flatbuffers::Vector<float> *elements() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ELEMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_DIMS) &&
           VerifyOffset(verifier, VT_DIM_SIZES) &&
           verifier.VerifyVector(dim_sizes()) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           verifier.EndTable();
  }
};

struct MatrixNDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_dims(int32_t num_dims) {
    fbb_.AddElement<int32_t>(MatrixND::VT_NUM_DIMS, num_dims, 0);
  }
  void add_dim_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim_sizes) {
    fbb_.AddOffset(MatrixND::VT_DIM_SIZES, dim_sizes);
  }
  void add_elements(flatbuffers::Offset<flatbuffers::Vector<float>> elements) {
    fbb_.AddOffset(MatrixND::VT_ELEMENTS, elements);
  }
  explicit MatrixNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixNDBuilder &operator=(const MatrixNDBuilder &);
  flatbuffers::Offset<MatrixND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixND>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixND> CreateMatrixND(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_dims = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> elements = 0) {
  MatrixNDBuilder builder_(_fbb);
  builder_.add_elements(elements);
  builder_.add_dim_sizes(dim_sizes);
  builder_.add_num_dims(num_dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatrixND> CreateMatrixNDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_dims = 0,
    const std::vector<int32_t> *dim_sizes = nullptr,
    const std::vector<float> *elements = nullptr) {
  auto dim_sizes__ = dim_sizes ? _fbb.CreateVector<int32_t>(*dim_sizes) : 0;
  auto elements__ = elements ? _fbb.CreateVector<float>(*elements) : 0;
  return workpackage::common::CreateMatrixND(
      _fbb,
      num_dims,
      dim_sizes__,
      elements__);
}

inline bool VerifyMatrix(flatbuffers::Verifier &verifier, const void *obj, Matrix type) {
  switch (type) {
    case Matrix_NONE: {
      return true;
    }
    case Matrix_Matrix2D: {
      auto ptr = reinterpret_cast<const Matrix2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Matrix_Matrix3D: {
      auto ptr = reinterpret_cast<const Matrix3D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Matrix_MatrixND: {
      auto ptr = reinterpret_cast<const MatrixND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMatrixVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMatrix(
        verifier,  values->Get(i), types->GetEnum<Matrix>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace common
}  // namespace workpackage

#endif  // FLATBUFFERS_GENERATED_COMMON_WORKPACKAGE_COMMON_H_
